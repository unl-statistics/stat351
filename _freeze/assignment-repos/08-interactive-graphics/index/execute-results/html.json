{
  "hash": "2a4efc7ae0cd2fba59cf3831e7276d58",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Homework: Interactive Visualization with Vega-Lite\"\nauthor: \"Your Name\"\nformat: html\ntheme: cosmo\n---\n\n# Introduction\n\nIn this assignment, you will create interactive charts using **Vega-Lite** inside a **Quarto document** with ObservableJS chunks.\nComplete all sections and provide brief explanations for each chart.\n\n```{ojs}\n// This sets up observable JS\nimport {vl} from \"@observablehq/vega-lite\"\n```\n\n## Setting Up\n\nFor this lab, we'll use the XKCD Color survey data.\nThe TidyTuesday documentation is available [here](https://github.com/rfordatascience/tidytuesday/blob/main/data/2025/2025-07-08/readme.md).\n\nObservable does best with data that's local, so we'll read the CSVs into R objects and write them out to local CSVs (yes, we could just download them... but this gives you the chance to do an exploratory data analysis in R if you prefer.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanswers <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2025/2025-07-08/answers.csv')\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 1058211 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): hex\ndbl (2): user_id, rank\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\ncolor_ranks <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2025/2025-07-08/color_ranks.csv')\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 949 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): color, hex\ndbl (1): rank\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nusers <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2025/2025-07-08/users.csv')\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 152401 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): monitor\ndbl (4): user_id, y_chromosome, colorblind, spam_prob\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nwrite.csv(answers, \"data/answers.csv\")\nwrite.csv(color_ranks, \"data/color_ranks.csv\")\nwrite.csv(users, \"data/users.csv\")\n```\n:::\n\n\n```{ojs}\n// Imports\nd3 = require(\"d3@7\")\nimport {Inputs} from \"@observablehq/inputs\"\n\n// Load color_ranks.csv (preferred) or sample fallback\nraw = await FileAttachment(\"data/color_ranks.csv\").csv({typed: false});\n\n// Parse hex -> RGB/HSL\ncolors = raw.map(d => {\n  const hex = d.hex?.trim();\n  const name = d.color ?? d.name ?? d.Color ?? \"unknown\";\n  const c = d3.color(hex);\n  const hsl = d3.hsl(c);\n  return {\n    color: name,\n    hex,\n    rank: +d.rank,\n    r: c?.r ?? NaN,\n    g: c?.g ?? NaN,\n    b: c?.b ?? NaN,\n    h: ((hsl?.h ?? NaN) + 360) % 360,\n    s: (hsl?.s ?? NaN) * 100,\n    l: (hsl?.l ?? NaN) * 100\n  }\n}).filter(d => d.hex && !Number.isNaN(d.h) && !Number.isNaN(d.l))\n\n\n// Parse hex -> RGB/HSL and compute a hue family bucket\nallColors = raw.map(d => {\n  const hex = d.hex?.trim();\n  const name = d.color ?? d.name ?? d.Color ?? \"unknown\";\n  const c = d3.color(hex);\n  const hsl = d3.hsl(c);\n  const h = ((hsl?.h ?? NaN) + 360) % 360;\n  const s = (hsl?.s ?? NaN) * 100;\n  const l = (hsl?.l ?? NaN) * 100;\n  const family = (s < 10 || l > 95) ? \"Grays/Whites\" :\n    (h < 15 || h >= 345) ? \"Reds\" :\n    (h < 45) ? \"Oranges\" :\n    (h < 70) ? \"Yellows\" :\n    (h < 170) ? \"Greens\" :\n    (h < 200) ? \"Cyans\" :\n    (h < 255) ? \"Blues\" :\n    (h < 290) ? \"Purples\" :\n    (h < 330) ? \"Pinks\" : \"Reds\";\n  return {color: name, hex, rank: +d.rank, r: c?.r ?? NaN, g: c?.g ?? NaN, b: c?.b ?? NaN, h, s, l, family}\n}).filter(d => d.hex)\n```\n\n# Interactive Exploration\n\nI asked CoPilot to generate an observable plot that uses selectors to change the color space and saturation.\nI've modified its code to both fix errors and explain more things using comments. \n\nIt may help to bring up Wikipedia pages for [RGB](https://en.wikipedia.org/wiki/RGB_color_model) and [HSL](https://en.wikipedia.org/wiki/HSL_and_HSV) color models. \n\n```{ojs}\n// selector for color space -- changes plot axes\nviewof space = Inputs.select([\"HSL\", \"RGB\"], {label: \"Color space (axes)\", value: \"HSL\"})\n// selector for color saturation/intensity\nviewof minSat = Inputs.range([0, 100], {label: \"Min saturation (%)\", value: 0, step: 1})\n\n\n// filter out points based on saturation\nfiltered = colors.filter(d => d.s >= minSat)\n\n// Create an x variable that's conditional on what is selected,\n// changing both the values and the label accordingly\nxAccessor = space === \"HSL\" ? (d) => d.h : (d) => d.r\nxLabel = space === \"HSL\" ? \"Hue (°)\" : \"Red (0–255)\"\n\n// Create a y variable that's conditional on what is selected,\n// changing both the values and the label accordingly\nyAccessor = space === \"HSL\" ? (d) => d.l : (d) => d.g\nyLabel = space === \"HSL\" ? \"Lightness (%)\" : \"Green (0–255)\"\n```\n\n```{ojs}\nPlot.plot({\n  grid: true, // show coordinate grid\n  color: {legend: false}, // no need for legends when the data is colors\n  marks: [\n    Plot.dot(\n      filtered, // use filtered data\n      {\n        x: xAccessor, y: yAccessor, // specify mappings\n        fill: (d) => d.hex,\n        stroke: \"#333\", strokeWidth: 0.5, r: 5, // and defaults\n        tip: true,\n        // title = tooltip text. use both color name and hex value\n        title: d => `${d.color} (${d.hex})\n  HSL: ${d.h.toFixed(0)}, ${d.s.toFixed(0)}%, ${d.l.toFixed(0)}%\n  RGB: ${d.r}, ${d.g}, ${d.b}`\n      }\n    )],\n  x: {label: xLabel, domain: space === \"HSL\" ? [0, 360] : [0, 255]},\n  y: {label: yLabel, domain: space === \"HSL\" ? [0, 100] : [0, 255]},\n  caption: space === \"HSL\" ? \"Hue vs. Lightness (filtered by min saturation).\" : \"Red vs. Green (still filtered by HSL saturation).\"\n})\n```\n\n## Alternatives\n\nCan you think of a better way to display this data, potentially using similar selectors? Describe the changes you'd make. \n\n> \n\nIs your proposed graphic supported by vega-lite? Why or why not? (You can provide links to documentation/stackOverflow)\n\n> \n\n\n## Adding selectors\n\nAdd a `maxSat2` selector that puts an upper bound on the saturation. \nTo ensure mathematical viability, your `maxSat2` selector should have a lower bound of `minSat2`.\nWire your `maxSat2` selector to the plot, using the chunk below, which I've edited to use variables with `2` at the end to not conflict with the original chart. \n\n\n```{ojs}\n// selector for color space -- changes plot axes\nviewof space2 = Inputs.select([\"HSL\", \"RGB\"], {label: \"Color space (axes)\", value: \"HSL\"})\n// selector for color saturation/intensity\nviewof minSat2 = Inputs.range([0, 100], {label: \"Min saturation (%)\", value: 0, step: 1})\n\n\n// filter out points based on saturation\nfiltered2 = colors.filter(d => d.s >= minSat2)\n\n// Create an x variable that's conditional on what is selected,\n// changing both the values and the label accordingly\nxAccessor2 = space === \"HSL\" ? (d) => d.h : (d) => d.r\nxLabel2 = space === \"HSL\" ? \"Hue (°)\" : \"Red (0–255)\"\n\n// Create a y variable that's conditional on what is selected,\n// changing both the values and the label accordingly\nyAccessor2 = space === \"HSL\" ? (d) => d.l : (d) => d.g\nyLabel2 = space === \"HSL\" ? \"Lightness (%)\" : \"Green (0–255)\"\n```\n\n```{ojs}\nPlot.plot({\n  grid: true, // show coordinate grid\n  color: {legend: false}, // no need for legends when the data is colors\n  marks: [\n    Plot.dot(\n      filtered2, // use filtered data\n      {\n        x: xAccessor2, y: yAccessor2, // specify mappings\n        fill: (d) => d.hex,\n        stroke: \"#333\", strokeWidth: 0.5, r: 5, // and defaults\n        tip: true,\n        // title = tooltip text. use both color name and hex value\n        title: d => `${d.color} (${d.hex})\n  HSL: ${d.h.toFixed(0)}, ${d.s.toFixed(0)}%, ${d.l.toFixed(0)}%\n  RGB: ${d.r}, ${d.g}, ${d.b}`\n      }\n    )],\n  x: {label: xLabel2, domain: space === \"HSL\" ? [0, 360] : [0, 255]},\n  y: {label: yLabel2, domain: space === \"HSL\" ? [0, 100] : [0, 255]},\n  caption: space === \"HSL\" ? \"Hue vs. Lightness (filtered by min saturation).\" : \"Red vs. Green (still filtered by HSL saturation).\"\n})\n```\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}