{
  "hash": "f19b52d7e370b3d0249b84bbf74a2de6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"HTML, XML, CSS, and XPath\"\nsubtitle: \"The Building Blocks of the Internet\"\necho: true\n---\n\n\n\n## Why?\n\n- So much data is online!\n- But, ...\n    - Manually copying information is error prone\n    - Stuff is updated in real time\n    - I'm lazy\n\n- We can automate gathering data using scripts\n\n## Examples {.smaller}\n\n- Gather the price of something every morning at 8am to determine whether it's cheap enough to buy\n\n- Estimate what you could sell your house for, given recent sales of comparable houses in the same city\n\n- Create a database of adoptable pets in your area (with pics) and determine how long it takes for different pets to be adopted\n\n- Assemble a database of profiles on dating sites to determine whether gender and sexual orientation is related to emoticon/emoji use\n\n- Assemble a directory of contact information for all faculty at UNL to conduct an unofficial faculty survey\n\n## XML\n\n- relatively common data storage format\n- Fields are delimited by tags `<tagName attr1=value1 ...>`. All tags are closed with `</tagName>`\n\n- Tags may contain attribute-value pairs\n\n- Tags may have children nested between `<tagName>` and `</tagName>`\n\n- Tags may also contain \"content\" between the tags -- plain text information\n\n\n## XML Terms {.smaller}\n\n```\n<family name=\"Vanderplas\">\n    <person given-name=\"Susan\">Mother</person>\n    <person given-name=\"Ryan\">Father</person>\n    <person given-name=\"Alex\" nickname='Bug'>Son</person>\n    <person given-name=\"Zoey\" nickname='Zozo, Lovebug'>Daughter</person>\n    <pet type=\"dog\" given-name=\"Edison\" nickname=\"Eddie\">Security detail, Cleanup crew</pet>\n    <pet type=\"dog\" given-name=\"Ivy\" nickname=\"Flufferina, Q-tip\">Snuggle agent, Cleanup crew, Comic relief</pet>\n</family>\n```\n\n- `given-name` and `family-name` are **attributes** with values for each person and pet. `nickname` is an attribute, but is not present for all nodes\n\n- `<person>...</person>` and `<pet>...</pet>` are **child nodes** of `<family></family>`\n\n- The content of each child node is the entity's role in the family\n\n- XML data is **nested** and does not always translate to tabular form easily\n\n## HTML vs. XML\n\n::: columns\n::: column\n\n- Tags **display** information\n- Tags are pre-defined\n- Tags aren't always closed    \n[`<br/>`, `<img/>`]{.smaller}\n- Not case-sensitive\n- Ignores white-space\n:::\n::: column\n- Tags **describe** information\n- Data schema defines tags\n- Tags must be closed    \n&nbsp;\n- Case-sensitive\n- May ignore white space\n:::\n:::\n\n\n## Your Turn: Web Page Anatomy {.smaller .inverse}\n\n1. Open [the textbook chapter](https://srvanderplas.github.io/stat-computing-r-python/part-advanced-topics/03-web-scraping.html)\n2. Access Developer Tools for your browser\n    - right-click + select \"Inspect\" \n    - OR, Ctrl/Cmd + J\n\n3. Find the following elements. What attributes and content do they have?\n    - Document type declaration\n    - `<html>` node\n    - `<head>` and `<body>` nodes\n    - `<h2>`, `<h3>`, `<h4>` and `<p>` nodes\n    - `<table>`, `<tr>`, `<th>`, and `<td>` nodes\n    - `<a>` node(s)\n    \n## Selecting Nodes (CSS)\n\n- [SelectorGadget](https://selectorgadget.com/) extension can be helpful\n\n- `.xxx` = \"has class xxx\"\n- `#xxx` = \"has ID xxx\"\n- `xxx` = \"node xxx\"\n- `xxx yyy` = \"node yyy, a  descendant of xxx\"\n- `xxx > yyy` = \"node yyy, a direct descendant of xxx\"\n\n## Your Turn: CSS Selectors {.inverse}\n\nConstruct a CSS selector that will get all mathematicians from [this list](https://en.wikipedia.org/wiki/List_of_mathematicians_born_in_the_19th_century) without any extra links.\n\n\n## Example: Mathematicians\n\n::: panel-tabset\n### R {-}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(xml2)\nlibrary(rvest)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(tibble)\n\nurl<-\"https://en.wikipedia.org/wiki/List_of_mathematicians_born_in_the_19th_century\"\nppl <- read_html(url) |>\n    html_nodes(\".mw-body-content ul li\")\nppl[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{html_node}\n<li>\n[1] <a href=\"/wiki/Florence_Eliza_Allen\" title=\"Florence Eliza Allen\">Florenc ...\n```\n\n\n:::\n:::\n\n\n\n### Python {-}\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom bs4 import BeautifulSoup, SoupStrainer\nimport urllib.request\nimport pandas as pd\n\nurl = \"https://en.wikipedia.org/wiki/List_of_mathematicians_born_in_the_19th_century\"\nreq = urllib.request.Request(url)\npage_bytearray = urllib.request.urlopen(req)\npage = page_bytearray.read()\npage_bytearray.close()\n\nsoup = BeautifulSoup(page)\nppl = soup.select(\".mw-body-content ul li\")\nppl[0]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<li><a href=\"/wiki/Florence_Eliza_Allen\" title=\"Florence Eliza Allen\">Florence Eliza Allen</a> (1876–1960)</li>\n```\n\n\n:::\n:::\n\n\n\n:::\n\n## Example: Mathematicians\n\nNot all HTML nodes have the same attributes/children.\n\nPreemptive error handling can be helpful.\n::: panel-tabset\n### R {-}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntry_na <- function(i, fn, ...) {\n    res <- try(fn(i, ...))\n    if( \"try-error\" %in% class(res)) {\n        res <- NA\n    }\n    if(length(res) == 0) {\n        res <- NA\n    }\n    res\n}\n```\n:::\n\n\n\n`try_na()` will return\n\n- the value if one exists, \n- NA if the command results in an error\n- NA if the result has 0 length\n\n### Python {-}\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef try_na(x, expression):\n  # If x is NA, then the result must also be NA\n  # for most HTML-parsing expressions... NOT FOOLPROOF\n  if pd.isna(x):\n    return pd.NA\n  else:\n    try:\n      res = eval(expression, {}, {\"x\": x})\n    except:\n      return pd.NA\n    if res is None: # Tests for an empty return value\n      return pd.NA\n    if len(res) == 0:\n      return pd.NA\n  return res\n```\n:::\n\n\n\n:::\n\n\n## Example: Mathematicians\n\n::: panel-tabset\n### R {-}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmath_ppl <- tibble(\n    content = html_text(ppl),\n    link_info = map(ppl, ~try_na(., fn = html_children)),\n    name = map_chr(link_info, ~try_na(., fn = html_text)),\n    name2 = map_chr(link_info, ~try_na(., fn = html_attr, \"title\")),\n    link = map_chr(link_info, ~try_na(., fn = html_attr, \"href\"))\n) |>\n    select(-link_info)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in xml_text(x, trim = trim) : Unexpected node type\nError in xml_text(x, trim = trim) : Unexpected node type\nError in xml_attr(x, name, default = default) : Unexpected node type\nError in xml_attr(x, name, default = default) : Unexpected node type\nError in xml_attr(x, name, default = default) : Unexpected node type\nError in xml_attr(x, name, default = default) : Unexpected node type\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(math_ppl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  content                                                      name  name2 link \n  <chr>                                                        <chr> <chr> <chr>\n1 Florence Eliza Allen (1876–1960)                             Flor… Flor… /wik…\n2 Emil Artin (1898–1962)                                       Emil… Emil… /wik…\n3 George David Birkhoff (1884–1944)                            Geor… Geor… /wik…\n4 Maxime Bôcher (1867–1918)                                    Maxi… Maxi… /wik…\n5 Leonard Eugene Dickson (1874–1954), algebra and number theo… Leon… Leon… /wik…\n6 Jesse Douglas (1897–1965), Fields Medalist                   Jess… Jess… /wik…\n```\n\n\n:::\n:::\n\n\n\n### Python {-}\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncontent = [try_na(i, \"x.text\") for i in ppl]\nlink_info = [try_na(i, \"x.find('a')\") for i in ppl]\nname = [try_na(i, 'x.text') for i in link_info]\nname2 = [try_na(i, 'x.attrs[\"title\"]') for i in link_info]\nlink = [try_na(i, 'x.attrs[\"href\"]') for i in link_info]\nmath_ppl = pd.DataFrame({'content': content, 'name': name, 'name2': name2, 'link': link})\n```\n:::\n\n\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}